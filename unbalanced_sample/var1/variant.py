import numpy as np

from decimal import Decimal
from scipy.stats import binom, norm
from tools import ProblemVariant, VariantTransformer


unbalanced_sample_variant1 = ProblemVariant(code="unbalanced_sample_var1")


class UnbalancedSampleVariant1(VariantTransformer):
    def __init__(self, code):
        self.code = code
        self.alpha = Decimal("0.05")
        self.beta = Decimal("0.2")
        self.relative_mde = Decimal("0.05")
        self.days_cnt = 14

    def _get_transformed_random_state(self, random_state):
        min_num = 1
        max_num = 10
        return (min_num + (random_state % (max_num - min_num + 1))) / 100

    def get_sample(self, random_state):
        p = self._get_transformed_random_state(random_state)
        return binom(self.days_cnt, p).rvs(size=300000)

    def get_description(self, random_state):
        problem_text = f"""
*Контекст*
Нам кажется, что в текущем виде
у клиента мало инструментов
для анализа своих финансовых активов.
Мы хотим попробовать добавить в мобильное приложение
аналитику по тратам клиента.

*Тест*
Мы не знаем, зайдёт ли клиентам MVP такого функционала,
поэтому хотим провести тест, где небольшой части клиентов
мы включим новый функционал,
а другой - оставим текущий интерфейс.
Поговорив с коллегами,
мы решили,
что целевой метрикой теста
будет количество дней с заходами в МП
среди первых {self.days_cnt} дней теста.

*Данные*
По текущей базе клиентов мы собрали статистику использования МП,
которая приложена к задаче.

*Статистические вводные*
Уровень значимости {self.alpha:.0%}.
Мы хотели бы различать {self.relative_mde:.0%}-ное
изменение целевой метрики
с вероятностью {1 - self.beta:.0%}.

*Задача*
Нам нужно понять,
какую минимальную долю людей мы можем отправить в тест,
чтобы получить статзначимый результат.
"""

        return problem_text

    def get_solution_description(self, random_state):
        sample = self.get_sample(random_state)
        mu = sample.mean()
        sigma_sqr = sample.var()
        sample_size = len(sample)
        mde = mu * float(self.relative_mde)

        c = sigma_sqr * ((norm.ppf(1 - float(self.alpha)) - norm.ppf(float(self.beta)))**2) \
            / (sample_size * (mde**2))
        gamma = 0.5 - np.sqrt(0.25 - c)

        return f"""
*Интерпретация условия*
У нас есть вся совокупность 
клиентов-пользователей МП,
которую мы хотим разбить в тесте на 2 вариации: 
контрольную и тестовую.
Таким образом, зафиксирован размер контрольной вариации 
+ размер тестовой вариации
= количество пользователей МП.

Нам же, используя остальные данные,
нужно определить долю тестовой вариации.
То есть нам нужно взять формулы размера вариаций
в случае произвольных долей теста/контроля,
сложить их и зафиксировать сумму (она нам дана).
Неизвестным параметром в таком уравнении будет доля тестовой выборки.

*Данные*
Так как количество клиентов примерно стабильно,
а выборка в файле собрана примерно как в нашем тесте,
то общее количество клиентов на тесте (L): {sample_size}.

Метрика теста является небинарной, 
так как количество заходов в МП за {self.days_cnt} дней 
у одного клиента принимает значения от {0} до {self.days_cnt}.
В таком случае нам из данных в файле формул
нужно посчитать среднее и дисперсию.

Выборочное среднее (m): {mu:.3f}.
Выборочная дисперсия (s^2): {sigma_sqr:.3f}.

В условии сказано,
что хотели бы увидеть {self.relative_mde:.0%}-ное
изменение целевой метрики,
поэтому Up lift = {self.relative_mde:.0%}.
Используя выборочное среднее,
отсюда вычисляем MDE (d): {mde:.3f}.

Уровень значимости (a) задан явно: {self.alpha:.0%}
При этом мы проверяет идею 
"зайдёт ли клиентам MVP такого функционала",
то есть рассматриваем одностороннюю альтернативу,
что метрика на тесте будет больше, чем на контроле.

При наличии изменения как минимум на Up Lift
мы хотим увидеть стат. значимое изменение 
с вероятностью {1 - self.beta:.0%}.
То есть при наличии изменения как минимум на Up Lift
мы не хотим совершить ошибку (II рода)
с вероятностью {1 - self.beta:.0%}.
Поэтому вероятность ошибки II рода (b)
мы ограничиваем сверху {self.beta:.0%}.

*Решение*
Пусть:
g - доля тестовой выборки (вариации);
n - размер выборки в тестовой вариации;
m - размер выборки в контрольной вариации.

Из лекции мы знаем формулы
для определения размера выборок:
n(g) = s^2 (z(1-a) - z(b))^2 / ((1-g) d^2),
m(g) = s^2 (z(1-a) - z(b))^2 / (g d^2),
где z(x) - x-квантиль 
стандартного нормального распределения.

Так как величина L = n(g) + m(g) известна, то
нужно из этого равенства нужно выразить g.
Отметим, что
L = n(g) + m(g) = (1 / (1-g) + 1 / g)
s^2 (z(1-a) - z(b))^2 / d^2
= s^2 (z(1-a) - z(b))^2 / (g (1-g) d^2).
Отсюда можно выделить часть с g:
g (1-g) = s^2 (z(1-a) - z(b))^2 / (L d^2).
Обозначим величину в правой части через c.
Её можно посчитать: c = {c:.5f}.

Осталось решить только квадратное уравнение
g (1 - g) = c,
или
g^2 - g + c = 0.
Решая квадратное уравнение через дискриминант, получаем
g = 0.5 +- (0.25 - c)^(1/2).
Так как от нас просят наименьшую долю теста g,
то мы выбираем знак, при котором g имеем наименьшее значение.
Поэтому
g = 0.5 - (0.25 - c)^(1/2) = {gamma:.3f}.
"""
