import numpy as np

from decimal import Decimal
from scipy.stats import bernoulli, norm
from tools import ProblemVariant, VariantTransformer


unbalanced_sample_variant2 = ProblemVariant(code="unbalanced_sample_var2")


class UnbalancedSampleVariant2(VariantTransformer):
    def __init__(self, code):
        self.code = code
        self.alpha = Decimal("0.03")
        self.beta = Decimal("0.1")
        self.relative_mde = Decimal("0.1")
        self.days_cnt = 7
        self.dau = 150000

    def _get_transformed_random_state(self, random_state):
        min_num = 5
        max_num = 20
        return (min_num + (random_state % (max_num - min_num + 1))) / 100

    def get_sample(self, random_state):
        p = self._get_transformed_random_state(random_state)
        return bernoulli(p).rvs(size=50000)

    def get_description(self, random_state):
        problem_text = f"""
*Контекст*
Мы хотим встроить в экран платежа 
нашу новую услугу.
Наши коллеги с команды платежей переживают,
что наша доработка
снизит конверсию экрана платежа.

*Тест*
Мы хотим провести тест, 
где на небольшую часть клиентов раскатим 
экран платежей с нашей услугой,
а остальной части клиентов
будем показывать старую версию экрана.
При этом мы хотим провести тест за {self.days_cnt} дней.

*Данные*
Через экран платежей в среднем проходят {self.dau} людей в день.
Статистика совершения платежей в МП
приведена в файле, приложенном к задаче.

*Статистические вводные*
Уровень значимости {self.alpha:.0%}.
Мы хотели бы различать {self.relative_mde:.0%}-ное
изменение целевой метрики
с вероятностью {1 - self.beta:.0%}.

*Задача*
Нам нужно понять,
какую минимальную долю людей можно отправлять в тест,
учитывая сроки проведения теста.
"""

        return problem_text

    def get_solution_description(self, random_state):
        sample = self.get_sample(random_state)
        mu = sample.mean()
        sigma_sqr = sample.var()
        sample_size = self.days_cnt * self.dau
        mde = mu * float(self.relative_mde)

        c = sigma_sqr * ((norm.ppf(1 - float(self.alpha)) - norm.ppf(float(self.beta))) ** 2) \
            / (sample_size * (mde ** 2))
        gamma = 0.5 - np.sqrt(0.25 - c)

        return f"""
*Интерпретация условия*
Нам явно заданы длительность теста
и количество людей, 
которое будет принимать участие в тесте 
ежедневно.
Таким образом, зафиксирован размер контрольной вариации 
+ размер тестовой вариации
= количество участников теста.

Нам же, используя остальные данные,
нужно определить долю тестовой вариации.
То есть нам нужно взять формулы размера вариаций
в случае произвольных долей теста/контроля,
сложить их и зафиксировать сумму (она нам дана).
Неизвестным параметром в таком уравнении будет доля тестовой выборки.

*Данные*
Суммарное количество участников теста (L)
определяется как длительность теста ({self.days_cnt} дней),
умноженное на DAU экрана ({self.dau} людей)
= {sample_size} людей.

Метрика теста является бинарной,
так как нас интересует конверсия экрана платежа.
Поэтому нам достаточно оценить
конверсию экрана из файла (p): {mu:.3f}.

В условии сказано,
что хотели бы увидеть {self.relative_mde:.0%}-ное
изменение целевой метрики,
поэтому Down lift = {self.relative_mde:.0%} 
(как Up Lift, только в сторону понижения).
Используя рассчитанную конверсию,
отсюда вычисляем MDE (d): {mde:.3f}.

Уровень значимости (a) задан явно: {self.alpha:.0%}.
Нам интересно понять,
уменьшится ли конверсия экрана,
поэтому мы рассматриваем одностороннюю альтернативу,
что метрика на тесте будет меньше, чем на контроле.

При наличии изменения как минимум на Down Lift
мы хотим увидеть стат. значимое изменение 
с вероятностью {1 - self.beta:.0%}.
То есть при наличии изменения как минимум на Down Lift
мы не хотим совершить ошибку (II рода)
с вероятностью {1 - self.beta:.0%}.
Поэтому вероятность ошибки II рода (b)
мы ограничиваем сверху {self.beta:.0%}.

*Решение*
Пусть:
g - доля тестовой выборки (вариации);
n - размер выборки в тестовой вариации;
m - размер выборки в контрольной вариации.

Из лекции мы знаем формулы
для определения размера выборок:
n(g) = p (1-p) (z(1-a) - z(b))^2 / ((1-g) d^2),
m(g) = p (1-p) (z(1-a) - z(b))^2 / (g d^2),
где z(x) - x-квантиль 
стандартного нормального распределения.

Так как величина L = n(g) + m(g) известна, то
нужно из этого равенства нужно выразить g.
Отметим, что
L = n(g) + m(g) = (1 / (1-g) + 1 / g)
p (1-p) (z(1-a) - z(b))^2 / d^2
= p (1-p) (z(1-a) - z(b))^2 / (g (1-g) d^2).
Отсюда можно выделить часть с g:
g (1-g) = p (1-p) (z(1-a) - z(b))^2 / (L d^2).
Обозначим величину в правой части через c.
Её можно посчитать: c = {c:.5f}.

Осталось решить только квадратное уравнение
g (1 - g) = c,
или
g^2 - g + c = 0.
Решая квадратное уравнение через дискриминант, получаем
g = 0.5 +- (0.25 - c)^(1/2).
Так как от нас просят наименьшую долю теста g,
то мы выбираем знак, при котором g имеем наименьшее значение.
Поэтому
g = 0.5 - (0.25 - c)^(1/2) = {gamma:.3f}.
"""
