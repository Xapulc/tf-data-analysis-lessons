import numpy as np

from decimal import Decimal
from scipy.stats import bernoulli, norm
from tools import ProblemVariant, VariantTransformer


unbalanced_sample_variant3 = ProblemVariant(code="unbalanced_sample_var3")


class UnbalancedSampleVariant3(VariantTransformer):
    def __init__(self, code):
        self.code = code
        self.alpha = Decimal("0.05")
        self.beta = Decimal("0.1")
        self.relative_mde = Decimal("0.05")
        self.days_cnt = 28
        self.total_days_cnt = 14
        self.dau = 20000

    def _get_transformed_random_state(self, random_state):
        min_num = 6
        max_num = 30
        return (min_num + (random_state % (max_num - min_num + 1))) / 100

    def get_sample(self, random_state):
        p = self._get_transformed_random_state(random_state)
        return bernoulli(p).rvs(size=self.days_cnt * self.dau)

    def get_description(self, random_state):
        problem_text = f"""
*Контекст*
Организация работы с операторами
дорога и сложна.
Мы хотим попробовать внедрить
продажные звонки роботом,
притом так,
чтобы он продавал лучше операторов.

*Тест*
Небольшую часть потока заданий
мы хотим перевести на продажного робота.
В этом тесте мы хотим сделать вывод о том,
кто лучше - оператор или робот.

*Данные*
Результаты заданий (продали продукт или нет)
за последние {self.days_cnt} дней
приведены в файле,
присылаемом вместе с заданием.

*Статистические вводные*
Уровень значимости {self.alpha:.0%}.
Мы хотели бы различать {self.relative_mde:.0%}-ное
изменение целевой метрики
с вероятностью {1 - self.beta:.0%}.

*Задача*
Нам нужно понять,
какую максимальную долю заданий можно оставить операторам,
учитывая,
что тест мы хотим завершить за {self.total_days_cnt} дней.
"""

        return problem_text

    def get_solution_description(self, random_state):
        sample = self.get_sample(random_state)
        mu = sample.mean()
        sigma_sqr = sample.var()
        sample_size = self.total_days_cnt * len(sample) / self.days_cnt
        mde = mu * float(self.relative_mde)

        c = sigma_sqr * ((norm.ppf(1 - float(self.alpha / 2)) - norm.ppf(float(self.beta))) ** 2) \
            / (sample_size * (mde ** 2))
        gamma = 0.5 + np.sqrt(0.25 - c)

        return f"""
*Интерпретация условия*
В задании спрашивается определение максимальной доли
контрольной выборки (с операторами),
если тест проводить фиксированное количество дней.
Для того, чтобы максимизировать долю контрольной выборки,
нужно рассмотреть весь поток звонков
за это количество времени,
и отсюда рассчитать сколько заданий нужно отдать на тест.
Таким образом, зафиксирован размер контрольной вариации 
+ размер тестовой вариации
= количество участников теста.

Нам же, используя остальные данные,
нужно определить долю контрольной вариации.
То есть нам нужно взять формулы размера вариаций
в случае произвольных долей теста/контроля,
сложить их и зафиксировать сумму (она нам дана).
Неизвестным параметром в таком уравнении будет доля контрольной выборки.

*Данные*
Нам дан файл с обработкой звонков за {self.days_cnt} дней.
И за это время обработано {len(sample)} звонков.
То есть в день обрабатывается {len(sample) / self.days_cnt:.0f} звонков.
Нам же нужно понять суммарное количество участников теста (L)
за {self.total_days_cnt} дней.
Оно равно количеству дней, 
умноженному на среднее количество звонков за день,
то есть L = {self.total_days_cnt * len(sample) / self.days_cnt:.0f}.

Нам хочется понять, стал ли робот лучше продавать,
то есть повысилась ли конверсия продаж.
В таком случае метрика теста является бинарной,
и конверсию можно оценить из файла (p): {mu:.3f}.

В условии сказано,
что хотели бы увидеть {self.relative_mde:.0%}-ное
изменение целевой метрики,
поэтому Up lift = {self.relative_mde:.0%}.
Используя рассчитанную конверсию,
отсюда вычисляем MDE (d): {mde:.3f}.

Уровень значимости (a) задан явно: {self.alpha:.0%}.
Нам интересно понять,
увеличится ли конверсия продаж у робота,
поэтому мы рассматриваем одностороннюю альтернативу,
что метрика на тесте будет больше, чем на контроле.

При наличии изменения как минимум на Up Lift
мы хотим увидеть стат. значимое изменение 
с вероятностью {1 - self.beta:.0%}.
То есть при наличии изменения как минимум на Up Lift
мы не хотим совершить ошибку (II рода)
с вероятностью {1 - self.beta:.0%}.
Поэтому вероятность ошибки II рода (b)
мы ограничиваем сверху {self.beta:.0%}.

*Решение*
Пусть:
g - доля контрольной выборки (вариации);
n - размер выборки в тестовой вариации;
m - размер выборки в контрольной вариации.

Из лекции мы знаем формулы
для определения размера выборок:
n(g) = p (1-p) (z(1-a) - z(b))^2 / (g d^2),
m(g) = p (1-p) (z(1-a) - z(b))^2 / ((1-g) d^2),
где z(x) - x-квантиль 
стандартного нормального распределения.

Так как величина L = n(g) + m(g) известна, то
нужно из этого равенства нужно выразить g.
Отметим, что
L = n(g) + m(g) = (1 / g + 1 / (1-g))
p (1-p) (z(1-a) - z(b))^2 / d^2
= p (1-p) (z(1-a) - z(b))^2 / (g (1-g) d^2).
Отсюда можно выделить часть с g:
g (1-g) = p (1-p) (z(1-a) - z(b))^2 / (L d^2).
Обозначим величину в правой части через c.
Её можно посчитать: c = {c:.5f}.

Осталось решить только квадратное уравнение
g (1 - g) = c,
или
g^2 - g + c = 0.
Решая квадратное уравнение через дискриминант, получаем
g = 0.5 +- (0.25 - c)^(1/2).
Так как от нас просят наибольшую долю контроля g,
то мы выбираем знак, при котором g имеем наибольшее значение.
Поэтому
g = 0.5 + (0.25 - c)^(1/2) = {gamma:.3f}.
"""
